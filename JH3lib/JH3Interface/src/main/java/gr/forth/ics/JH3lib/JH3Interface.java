package gr.forth.ics.JH3lib;

import com.sun.jna.*;
import com.sun.jna.ptr.NativeLongByReference;
import com.sun.jna.ptr.PointerByReference;

import java.nio.IntBuffer;

/**
 * Interface that maps h3lib's native functions to Java.
 * @author Giorgos Kalaentzis
 * @version 0.1-beta
 */
public interface JH3Interface extends Library {
    // public static final String JNA_LIBRARY_NAME = "/usr/local/lib/libH3.so";
    // public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(JH3libInterface.JNA_LIBRARY_NAME);
    // public static final JH3libInterface INSTANCE = (JH3libInterface) Native.load(JH3libInterface.JNA_LIBRARY_NAME, JH3libInterface.class);

    /** The instance of the native h3lib. */
    JH3Interface INSTANCE = LibraryLoader.load(); 

    // Defines of H3
    /** Maximum number of characters allowed for a bucket. */
    int H3_BUCKET_NAME_SIZE = 64;

    /** Maximum number of characters allowed for an object. */
    int H3_OBJECT_NAME_SIZE = 512;

    /**  This character can only appear at the end of an object-name */
    String H3_LAST_ONLY_CHAR = (String)"%";
  
    /** Status/error codes supported by H3; Represents values of H3_Status enum */
    interface Status {
        /** Operation failed. */
        int H3_FAILURE = 0;
        /** Arguments are missing or malformed. */
        int H3_INVALID_ARGS = 1;
        /** External (store provider) error. */
        int H3_STORE_ERROR = 2;
        /** Bucket or object already exists. */
        int H3_EXISTS = 3;
        /** Bucket or object does not exist. */
        int H3_NOT_EXISTS = 4;
        /** Bucket or object name is too long. */
        int H3_NAME_TOO_LONG = 5;
        /** Bucket is not empty. */
        int H3_NOT_EMPTY = 6;
        /** Operation succeeded. */
        int H3_SUCCESS = 7;
        /** Operation succeeded though there are more data to retrieve. */
        int H3_CONTINUE = 8;
    }

    /** Object/Bucket attributes supported by H3. */
    interface AttributeType {
        /** Permission attribute. */
        int H3_ATTRIBUTE_PERMISSIONS = 0;
        /** Owner attributes. */
        int H3_ATTRIBUTE_OWNER = 1;
        /** Not an option, used for iteration purposes. */
        int H3_NumOfAttributes = 2;
    }

    /**  Callback function to be invoked for each bucket or object. */
    interface h3_name_iterator_cb extends Callback {
        void apply(Pointer name, Pointer userData);
    }

    /**
     * Returns the version string
     * @return Null terminated string
     */
    Pointer H3_Version();


    //----------------------- Handle Management -----------------------
    /**
     * Initialize an H3 library.
     * @param   storageURI      The backend storage URI.
     * @return                  The handle if connected to provider, NULL otherwise.
     */
    Pointer H3_Init(Pointer storageURI);

    /**
     * Destroy an h3lib handle. Deallocates buffers and renders handle inoperable. Using the handle after it has
     * been freed leads to unexpected behavior.
     * @param   handle A handle previously generated by H3_Init()
     */
    void H3_Free(Pointer handle);

    //--------------------- Bucket Management -----------------------
    /**
     * Create a bucket. The bucket is associated with a specific user(derived from the token). The bucket name must not
     * exceed a certain size and may only consist of the following characters 0-9, a-z, A-Z,
     * _ (underscore) , - (minus) and . (dot).
     * @param   handle          An h3lib handle
     * @param   token           Authentication information
     * @param   bucketName      The name of the bucket to be created
     *
     * @return  H3_SUCCESS on success, or H3_EXISTS/H3_INVALID_ARGS/H3_STORE_ERROR on failure
     */
    int H3_CreateBucket(Pointer handle, NativeAuth token, Pointer bucketName);

    /**
     * Delete a bucket. For the bucket to be deleted it must be empty and the token must grant access to it.
     * @param   handle          An h3lib handle
     * @param   token           Authentication information
     * @param   bucketName      The name of the bucket to be deleted
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_DeleteBucket(Pointer handle, NativeAuth token, Pointer bucketName);

    /**
     * List buckets associated with a user. The buffer containing the bucket names is allocated internally and should be
     * freed by the user at the end. In case of error, no buffer is generated. The names are null terminated strings of
     * variable size, placed back to back into the buffer.
     *
     * @param   handle             An h3lib handle
     * @param   token              Authentication information
     * @param   bucketNameArray    Pointer to a buffer that is to be filled with the buckets names expressed as
     *                             null-terminated strings
     * @param   nBuckets           Number of buckets contained in the buffer
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_ListBuckets(Pointer handle, NativeAuth token, PointerByReference bucketNameArray, IntBuffer nBuckets);

    /**
     * Execute a user function for each bucket. Invokes the function for each bucket associated with the user,
     * passing it the bucket name and user provided data.
     *
     * @param   handle      An h3lib handle
     * @param   token       Authentication information
     * @param   function    User function to be invoked for each bucket
     * @param   userData    User data to be passed to the function
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
    */
    int H3_ForeachBucket(Pointer handle, NativeAuth token, JH3Interface.h3_name_iterator_cb function, Pointer userData);

    /**
     * Retrieve information about a bucket.
     *
     * @param   handle             An h3lib handle
     * @param   token              Authentication information
     * @param   bucketName         Name of bucket
     * @param   bucketInfo         User allocated structure to be filled with the info
     * @param   getStats           If set, aggregate object information will also be produced at the cost of response time
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_InfoBucket(Pointer handle, NativeAuth token, Pointer bucketName, NativeBucketInfo bucketInfo, byte getStats);


    /**
     * Set a bucket's permission bits
     * @param handle            An h3lib handle
     * @param token             Authentication information
     * @param bucketName        Name of bucket
     * @param attribute         Bucket attributes
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAULURE on failure
     */
    int H3_SetBucketAttributes(Pointer handle, NativeAuth token, Pointer bucketName, NativeAttribute attribute);

    //--------------------- Object Management ---------------------
    /**
     * Create an object.
     * Create an object associated with a specific user( derived from the token). The bucket must exist and the object
     * should not. The object name must not exceed a certain size and conform to the following rules:
     * <p>
     * 1. May only consist of characters 0-9, a-z, A-Z, _ (underscore). / (slash) , - (minus) and . (dot).
     * <p>
     * 2. Must not start with a slash
     * <p>
     * 3. A slash must not be followed by another one
     *
     * @param    handle             An h3lib handle
     * @param    token              Authentication information
     * @param    bucketName         The name of the bucket to host the object
     * @param    objectName         The name of the object to be created
     * @param    data               Pointer to object data
     * @param    size               Size of the object data
     *
     * @return H3_SUCCESS on success, or H3_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_CreateObject(Pointer handle, NativeAuth token, Pointer bucketName, Pointer objectName, Pointer data, NativeLong size);

    /**
     * Copy a part of an object into a new one.
     * Copies a segment of an object into another object provided the new name is not taken. Note that both objects
     * will rest within the same bucket.
     *
     * @param    handle             An h3lib handle
     * @param    token              Authentication information
     * @param    bucketName         The name of the bucket to host the object
     * @param    srcObjectName      The name of the object to be renamed
     * @param    dstObjectName      The new name to be assumed by the object
     * @param    offset             Offset with respect to the source object's 0x00 byte
     * @param    size               The amount of data to copy
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_CreateObjectCopy(Pointer handle, NativeAuth token, Pointer bucketName, Pointer srcObjectName, NativeLong offset, NativeLongByReference size, Pointer dstObjectName);

    /**
     * Delete an object. Permanently deletes an object.
     *
     * @param    handle             An h3lib handle
     * @param    token              Authentication information
     * @param    bucketName         The name of the bucket to host the object
     * @param    objectName         The name of the object to be created
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_DeleteObject(Pointer handle, NativeAuth token, Pointer bucketName, Pointer objectName);

    /**
     * Retrieve objects matching a pattern.
     * Produce a list of object names with object matching a given pattern. The pattern is a simple prefix
     * rather than a regular expression. The pattern must adhere to the object naming conventions.
     * Upon success the buffer will contain a number of variable sized C strings (stored back to back) thus
     * it is the responsibility of the user to dispose it. In case the internal buffer is not big enough to
     * fit all matching entries (indicated by the operation status) the user may invoke again the function
     * with an appropriately set offset in order to retrieve the next batch of names.
     * In case of an error, the buffer will not be created.
     *
     * @param   handle             An h3lib handle
     * @param   token              Authentication information
     * @param   bucketName         The name of the bucket to host the object
     * @param   prefix             The initial part of an object name
     * @param   offset             The number of matching names to skip
     * @param   objectNameArray    Pointer to a C string buffer
     * @param   nObjects           Number of names in buffer
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_ListObjects(Pointer handle, NativeAuth token, Pointer bucketName, Pointer prefix, int offset, PointerByReference objectNameArray, IntBuffer nObjects);

    /**
     * Execute a user provided function for each matching object.
     * Execute a user provided function for each object in a bucket matching a prefix. At each invocation the function
     * is passed the object's name along with the supplied user data.
     *
     * @param    handle             An h3lib handle
     * @param    token              Authentication information
     * @param    bucketName         The name of the bucket to host the object
     * @param    prefix             The initial part of an object name
     * @param    offset             The number of matching objects to skip
     * @param    function           The user function
     * @param    userData           The user data
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_ForeachObject(Pointer handle, NativeAuth token, Pointer bucketName, Pointer prefix, int nObjects, int offset, JH3Interface.h3_name_iterator_cb function, Pointer userData);

    /**
     *  Retrieve information about an object.
     * Retrieve an object's size, health status and creation, etc timestamps.
     *
     * @param    handle             An h3lib handle
     * @param    token              Authentication information
     * @param    bucketName         The name of the bucket to host the object
     * @param    objectName         The name of the object to be created
     * @param    objectInfo         Pointer to a data-structure to be filled with information
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_InfoObject(Pointer handle, NativeAuth token, Pointer bucketName, Pointer objectName, NativeObjectInfo objectInfo);

    /**
     *  Retrieve data from an object.
     * Retrieve an object's content staring at offset. If both size and data arguments are 0x00 and NULL respectively then a buffer
     * is allocated internally to fit the entire object. In this case it is the responsibility of the user to free the buffer.
     * If a size is provided it is expected that a valid buffer of appropriate size has also been provided.
     *
     * @param   handle             An h3lib handle
     * @param   token              Authentication information
     * @param   bucketName         The name of the bucket to host the object
     * @param   objectName         The name of the object to be created
     * @param   offset             Offset within the object's data
     * @param   data               Pointer to hold the data
     * @param   size               Size of data to retrieve or have been retrieved
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_ReadObject(Pointer handle, NativeAuth token, Pointer bucketName, Pointer objectName, NativeLong offset, PointerByReference data, NativeLongByReference size);

    /**
     * Write an object.
     * Write an object associated with a specific user( derived from the token). If the object exists it
     * will be overwritten. Sparse objects are supported.
     * The object name must not exceed a certain size and conform to the following rules:
     * <p>
     *  1. May only consist of characters 0-9, a-z, A-Z, _ (underscore). / (slash) , - (minus) and . (dot).
     * <p>
     * 2. Must not start with a slash <br>
     * <p>
     * 3. A slash must not be followed by another one
     *
     * @param    handle             An h3lib handle
     * @param    token              Authentication information
     * @param    bucketName         The name of the bucket to host the object
     * @param    objectName         The name of the object to be created
     * @param    data               Pointer to object data
     * @param    size               Size of the object data
     * @param    offset             Offset from the object's 0x00 byte
     *
     * @return H3_SUCCESS on success, or H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_WriteObject(Pointer handle, NativeAuth token, Pointer bucketName, Pointer objectName, Pointer data, NativeLong size, NativeLong offset);

    /**
     * Copy a part of an object into a new or existing one.
     * Copies a segment of an object into another object at a user provided offset. Note that both objects will rest within
     * the same bucket.
     *
     * @param    handle             An h3lib handle
     * @param    token              Authentication information
     * @param    bucketName         The name of the bucket to host the object
     * @param    srcObjectName      The name of the object to be renamed
     * @param    dstObjectName      The new name to be assumed by the object
     * @param    srcOffset          Offset with respect to the source object's 0x00 byte
     * @param    dstOffset          Offset with respect to the destination object's 0x00 byte
     * @param    size               The amount of data to copy
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_WriteObjectCopy(Pointer handle, NativeAuth token, Pointer bucketName, Pointer srcObjectName, NativeLong srcOffset, NativeLongByReference size, Pointer dstObjectName, NativeLong dstOffset);

    /**
     * Copy an object.
     * Copies and object provided the new name is not taken by another object unless it is explicitly allowed
     * by the user in which case the previous object will be overwritten. Note that both objects will rest within
     * the same bucket.
     *
     * @param    handle             An h3lib handle
     * @param    token              Authentication information
     * @param    bucketName         The name of the bucket to host the object
     * @param    srcObjectName      The name of the object to be renamed
     * @param    dstObjectName      The new name to be assumed by the object
     * @param    noOverwrite        Overwrite flag.
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_CopyObject(Pointer handle, NativeAuth token, Pointer bucketName, Pointer srcObjectName, Pointer dstObjectName, byte noOverwrite);

    /**
     * Rename an object.
     * Renames and object provided the new name is not taken by another object unless it is explicitly allowed
     * by the user in which case the previous object will be overwritten. Note that both objects will rest within
     * the same bucket.
     *
     * @param    handle             An h3lib handle
     * @param    token              Authentication information
     * @param    bucketName         The name of the bucket to host the object
     * @param    srcObjectName      The name of the object to be renamed
     * @param    dstObjectName      The new name to be assumed by the object
     * @param    noOverwrite        Overwrite flag.
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_MoveObject(Pointer handle, NativeAuth token, Pointer bucketName, Pointer srcObjectName, Pointer dstObjectName, byte noOverwrite);

    /**
     * Truncate an object.
     * Reduces size of an object.
     * @param handle            An h3lib handle
     * @param token             Authentication information
     * @param bucketName        The name of the bucket to host the object
     * @param objectName        The name of the object to be created
     * @param size              Size of truncated object. If the object previously was larger than this size, the extra
     *                          data is lost. If the object previously was shorter, it is extended, and the extended part
     *                          reads as null bytes ('\0')
     * @return H3_SUCCESS on success, or H3_FAILURE/H3_NOT_EXISTS/H3_INVALID_ARGS on failure
     */
    int H3_TruncateObject(Pointer handle, NativeAuth token, Pointer bucketName, Pointer objectName, NativeLong size);

    /**
     * Swap data between two objects.
     * Note that both objects will rest within the same bucket.
     * @param handle            An h3lib handle
     * @param token             Authentication information
     * @param bucketName        The name of the bucket to host the object
     * @param srcObjectName     The name of the first object to be exchanged
     * @param dstObjectName     The name of the second object to be exchanged
     * @return  H3_SUCCESS on success, or H3_FAILURE/H3_NOT_EXISTS/H3_INVALID_ARGS on failure
     */
    int H3_ExchangeObject(Pointer handle, NativeAuth token, Pointer bucketName, Pointer srcObjectName, Pointer dstObjectName);


    /**
     * Set an object's attribute. Currently only a file ode is supported.
     * @param handle            An h3lb handle
     * @param token             Authentication information
     * @param bucketName        The name of the bucket
     * @param objectName        The name of the object
     * @param attribute         The object attribute
     * @return
     */
    int H3_SetObjectAttributes(Pointer handle, NativeAuth token, Pointer bucketName, Pointer objectName, NativeAttribute attribute);

    //--------------------- Multipart Management ---------------------

    /**
     * Initiate a multipart object.
     * Initiate a multipart object associated with a specific user( derived from the token). Though the bucket must
     * exist there are no checks for the object itself since they are performed during completion. Once initiated the
     * object is accessed  through its ID rather than its name.
     * The object name must not exceed a certain size and conform to the following rules:
     * <p>
     * 1. May only consist of characters 0-9, a-z, A-Z, _ (underscore). / (slash) , - (minus) and . (dot).
     * <p>
     * 2. Must not start with a slash
     * <p>
     * 3. A slash must not be followed by another one
     *
     * @param   handle             An h3lib handle
     * @param   token              Authentication information
     * @param   bucketName         The name of the bucket to host the object
     * @param   objectName         The name of the object to be created
     * @param   multipartId        The id corresponding to the object
     *
     * @return H3_SUCCESS on success, or H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_CreateMultipart(Pointer handle, NativeAuth token, Pointer bucketName, Pointer objectName, PointerByReference multipartId);

    /**
     * Finalize a multipart object.
     * Converts a multipart object into an ordinary one by coalescing uploaded parts ordered by their part-ID.
     * If another object with that name already exists it is overwritten. Once completed, the multipart-ID is
     * invalidated thus the multipart API becomes in-applicable for the object.
     *
     * @param   handle              An h3lib handle
     * @param   token               Authentication information
     * @param   multipartId         The object id
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_CompleteMultipart(Pointer handle, NativeAuth token, Pointer multipartId);

    /**
     * Delete a multipart object.
     * Deletes a multipart object along with all uploaded parts if any. Once deleted, the multipart-ID is
     * invalidated.
     *
     * @param   handle             An h3lib handle
     * @param   token              Authentication information
     * @param   multipartId        The object id
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_AbortMultipart(Pointer handle, NativeAuth token, Pointer multipartId);

    /**
     * Get list of multipart objects.
     * Retrieve the ID of all multipart objects in a bucket into an internally allocated array.
     * Note it is the responsibility of the user to dispose the array except in case of error.
     *
     * @param   handle             An h3lib handle
     * @param   token              Authentication information
     * @param   offset             The number of IDs to skip
     * @param   multipartIdArray   An array of IDs
     * @param   nIds               The number of IDs
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_ListMultiparts(Pointer handle, NativeAuth token, Pointer bucketName, int offset, PointerByReference multipartIdArray, IntBuffer nIds);

    /**
     * Get part-list of a multipart object.
     * Retrieves information for each part of a multipart object into an internally allocated array.
     * Note it is the responsibility of the user to dispose the array except in case of error.
     *
     * @param   handle             An h3lib handle
     * @param   token              Authentication information
     * @param   multipartId        The object id
     * @param   partInfoArray      An array of parts
     * @param   nParts             The number of parts
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_ListParts(Pointer handle, NativeAuth token, Pointer multipartId, PointerByReference partInfoArray, IntBuffer nParts);

    /**
     * Create a single part of a multipart object from user data.
     * Creates a part of a multipart object designated by a number. If a part with the same number exists it is replaced by the new one.
     *
     * @param   handle             An h3lib handle
     * @param   token              Authentication information
     * @param   multipartId        The object id
     * @param   partNumber         The part number
     * @param   data               Pointer to user data
     * @param   size               The size of the data buffer
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_CreatePart(Pointer handle, NativeAuth token, Pointer multipartId, int partNumber, Pointer data, NativeLong size);

    /**
     * Create a single part of a multipart object from a pre-existing object.
     * Creates a part of a multipart object designated by a number. If a part with the same number exists it is replaced by the new one.
     * The data are sourced from an ordinary object expected to be hosted in the same bucket as the multipart one.
     *
     * @param   handle             An h3lib handle
     * @param   token              Authentication information
     * @param   objectName         The object name
     * @param   offset             Offset with respect to the ordinary object's 0x00 byte
     * @param   size               The size of the data to be copied
     * @param   multipartId        The object id
     * @param   partNumber         The part number
     *
     * @return H3_SUCCESS on success, or H3_NOT_EXISTS/H3_INVALID_ARGS/H3_FAILURE on failure
     */
    int H3_CreatePartCopy(Pointer handle, NativeAuth token, Pointer objectName, NativeLong offset, NativeLong size, Pointer multipartId, int partNumber);
}

class LibraryLoader {
    static JH3Interface load(){
        String JNA_LIBRARY_NAME = System.getenv("H3LIB_PATH");
        if(JNA_LIBRARY_NAME != null){
            return (JH3Interface) Native.load(JNA_LIBRARY_NAME, JH3Interface.class);
        } 
        // H3LIB_PATH was not specified; use default path
        return (JH3Interface) Native.load("h3lib", JH3Interface.class);
    }
}
